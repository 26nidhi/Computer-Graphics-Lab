<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2D Transformations</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="controls">
  <label for="shapeInput">Enter vertices (x,y):</label><br>
  <input type="text" id="shapeInput" placeholder="-50,-50 50,-50 50,50 -50,50" size="40">
  <button onclick="createCustomShape()">Draw Shape</button>
  <br><br>

  <!-- Transform buttons -->
  <button onclick="saveState(); translateShape()">Translate</button>
  <button onclick="saveState(); scaleShape()">Scale</button>
  <button onclick="saveState(); rotateShape()">Rotate</button>

  <!-- Reflection -->
  <select id="reflectAxis">
    <option value="x">Reflect X-axis</option>
    <option value="y">Reflect Y-axis</option>
    <option value="both">Reflect Origin</option>
  </select>
  <button onclick="saveState(); reflectShape()">Reflect</button>

  <!-- Shear -->
  <label for="shearX">Shear X:</label>
  <input type="number" id="shearX" value="0.5" step="0.1" style="width:50px">
  <label for="shearY">Shear Y:</label>
  <input type="number" id="shearY" value="0.5" step="0.1" style="width:50px">
  <button onclick="saveState(); shearShape()">Shear</button>

  <button onclick="undo()">Undo</button>
  <button onclick="redo()">Redo</button>
  <button onclick="resetShape()">Reset</button>

  <pre id="matrixDisplay"></pre>
</div>

  <!-- Your ES Module script goes here -->
   <script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js';

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(
  window.innerWidth / -2, window.innerWidth / 2,
  window.innerHeight / 2, window.innerHeight / -2,
  1, 1000
);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

let shape;
let originalVertices = null;
let history = [];
let redoHistory = [];

// Grid and axes
const grid = new THREE.GridHelper(1000, 20, 0x888888, 0xcccccc);
grid.rotation.x = Math.PI / 2;
scene.add(grid);

const axes = new THREE.AxesHelper(300);
scene.add(axes);

// Create shape
function createCustomShape() {
  if (shape) {
    scene.remove(shape);
    shape.geometry.dispose();
    shape.material.dispose();
  }
  history = [];
  redoHistory = [];

  const input = document.getElementById("shapeInput").value.trim();
  if (!input) return alert("Enter vertices in format: x1,y1 x2,y2 ...");

  const points = input.split(" ").map(p => p.split(",").map(Number));
  if (points.length < 3) return alert("At least 3 vertices required.");

  const verticesArray = [];
  points.forEach(p => verticesArray.push(p[0], p[1], 0));

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute(
    "position",
    new THREE.BufferAttribute(new Float32Array(verticesArray), 3)
  );

  const indices = [];
  for (let i = 1; i < points.length - 1; i++) indices.push(0, i, i + 1);
  geometry.setIndex(indices);

  const material = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
  shape = new THREE.Mesh(geometry, material);
  scene.add(shape);

  originalVertices = verticesArray.slice();
  updateMatrixDisplay();
}

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

// Transformations
function saveState() {
  if (shape) {
    history.push(shape.matrix.clone());
    redoHistory = [];
  }
}

function undo() {
  if (shape && history.length > 0) {
    redoHistory.push(shape.matrix.clone());
    const lastMatrix = history.pop();
    shape.matrix.copy(lastMatrix);
    shape.matrix.decompose(shape.position, shape.quaternion, shape.scale);
    updateMatrixDisplay();
  }
}

function redo() {
  if (shape && redoHistory.length > 0) {
    history.push(shape.matrix.clone());
    const nextMatrix = redoHistory.pop();
    shape.matrix.copy(nextMatrix);
    shape.matrix.decompose(shape.position, shape.quaternion, shape.scale);
    updateMatrixDisplay();
  }
}

function translateShape() {
  if(shape) {
    shape.position.add(new THREE.Vector3(100, 50, 0));
    updateMatrixDisplay();
  }
}

function scaleShape() {
  if(shape) {
    shape.scale.multiply(new THREE.Vector3(1.5, 1.5, 1));
    updateMatrixDisplay();
  }
}

function rotateShape() {
  if(shape) {
    shape.rotation.z += Math.PI/4;
    updateMatrixDisplay();
  }
}

function reflectShape() {
  if(!shape) return;
  const axis = document.getElementById("reflectAxis").value;
  const m = new THREE.Matrix4();
  if(axis === "x") m.set(-1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
  else if(axis === "y") m.set(1,0,0,0, 0,-1,0,0, 0,0,1,0, 0,0,0,1);
  else m.set(-1,0,0,0, 0,-1,0,0, 0,0,1,0, 0,0,0,1);
  shape.applyMatrix4(m);
  updateMatrixDisplay();
}

function shearShape() {
  if(!shape) return;
  const sx = parseFloat(document.getElementById("shearX").value);
  const sy = parseFloat(document.getElementById("shearY").value);
  const m = new THREE.Matrix4();
  m.set(1,sx,0,0, sy,1,0,0, 0,0,1,0, 0,0,0,1);
  shape.applyMatrix4(m);
  updateMatrixDisplay();
}

function resetShape() {
  if(shape && originalVertices){
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(originalVertices), 3));
    const indices = [];
    for (let i = 1; i < originalVertices.length/3 - 1; i++) indices.push(0,i,i+1);
    geometry.setIndex(indices);
    shape.geometry.dispose();
    shape.geometry = geometry;
    shape.position.set(0,0,0);
    shape.rotation.set(0,0,0);
    shape.scale.set(1,1,1);
    history = [];
    redoHistory = [];
    updateMatrixDisplay();
  }
}

// Matrix display
function updateMatrixDisplay() {
  if(!shape) return;
  const m = shape.matrix.elements;
  let str = "";
  for(let i=0;i<4;i++){
    str += m.slice(i*4,i*4+4).map(n => n.toFixed(2)).join("\t") + "\n";
  }
  document.getElementById("matrixDisplay").innerText = str;
}

// Expose functions to buttons
window.createCustomShape = createCustomShape;
window.translateShape = translateShape;
window.scaleShape = scaleShape;
window.rotateShape = rotateShape;
window.reflectShape = reflectShape;
window.shearShape = shearShape;
window.saveState = saveState;
window.undo = undo;
window.redo = redo;
window.resetShape = resetShape;

// Handle resize
window.addEventListener("resize", () => {
  camera.left = window.innerWidth / -2;
  camera.right = window.innerWidth / 2;
  camera.top = window.innerHeight / 2;
  camera.bottom = window.innerHeight / -2;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

 
</body>
</html>
